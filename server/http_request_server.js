// Generated by CoffeeScript 1.3.3

/*
@file http_request_server.coffee

@brief HTTP request server, spits back text/json. Used to query
       our db from the client.
@author Lucas Ray (ltray)
*/


(function() {
  var HTTPRequestServer, express;

  express = require('express');

  HTTPRequestServer = (function() {

    function HTTPRequestServer(port) {
      this.port = port;
      /*
          @brief Constructor for an HTTPRequestServer
      
          @param port The port we're listening on
      */

      this.init();
    }

    HTTPRequestServer.prototype.init = function() {
      /*
          @brief Initializes this server.
      */
      this.app = express();
      this.app.configure((function() {
        this.app.use(express.cookieParser());
        this.app.use(express.bodyParser());
        this.app.use(express.methodOverride());
        this.app.use(express.session({
          secret: 'whatisthis'
        }));
        return this.app.use(this.app.router);
      }).bind(this));
      return this.app.all('/json/:cmd', this.processJSONCmd.bind(this));
    };

    HTTPRequestServer.prototype.processJSONCmd = function(request, response) {
      /*
          @brief Processes a JSON command
      
          @param request The input request.
          @param response The output response.
      */

      var args, cmd;
      cmd = request.params.cmd;
      args = request.query;
      response.header("Cache-control", "no-cache");
      return this.cmdHandler(cmd, request.user, args, response);
    };

    HTTPRequestServer.prototype.cmdHandler = function(cmd, user, args, response) {
      /*
          @brief Generalized command handler.
      
          @param cmd Command we are handling.
          @param user User executing this command.
          @param args Arguments for this command.
          @param response Response we're writing to
      */

      var onFailure, onSuccess;
      onSuccess = (function(result) {
        return this.sendObjectAsJSON(response, {
          'result': result
        });
      }).bind(this);
      onFailure = (function(error) {
        return this.sendObjectAsJSON(response, {
          'err': error
        });
      }).bind(this);
      return this.cmdHandlers(this)[cmd](args, user, onSuccess, onFailure);
    };

    HTTPRequestServer.prototype.sendObjectAsJSON = function(response, object) {
      /*
          @brief Sends the input JSON object to user as text/json
      
          @param response The response we're writing to.
          @param object The object we're sending
      */
      response.write(JSON.stringify(object));
      return response.end();
    };

    HTTPRequestServer.prototype.cmdHandlers = (function(self) {
      return {
        getGreenscore: (function(args, user, onSuccess, onError) {
          return this.mysql_query(this.construct_greenscore_query(args), onSuccess, onError);
        }).bind(self),
        echo: (function(args, user, onSuccess, onError) {
          var ret;
          ret = "Echo: " + args.msg;
          return onSuccess(ret);
        }),
        sum: (function(args, user, onSuccess, onError) {
          var ret;
          ret = parseInt(args.x, 10) + parseInt(args.y, 10);
          return onSuccess(ret);
        })
      };
    });

    HTTPRequestServer.prototype.listen = function() {
      /*
          @brief Listens on the specified port.
      */

      var workingDir;
      console.log("Listening on port " + this.port);
      workingDir = __dirname + "/../app";
      this.app.use("/", express["static"](workingDir));
      this.app.get("/", (function(request, response) {
        return response.render(workingDir + "/index.html");
      }));
      this.app.listen(this.port);
      process.on("uncaughtException", this.onUncaughtException);
      return this.mysql_connect();
    };

    HTTPRequestServer.prototype.construct_greenscore_query = function(args) {
      /*
          @brief Constructs a greenscore SQL query given the input.
      
          @param args The arguments we're basing our query off of.
      */
      return "SELECT COFFEE FROM RECS05 LIMIT 0, 50";
    };

    HTTPRequestServer.prototype.mysql_connect = function() {
      /*
          @brief Establishes a connection with our sql database.
      */

      var mysql;
      mysql = require('mysql');
      this.conn = mysql.createConnection({
        host: 'kettle.ubiq.cs.cmu.edu',
        port: 3306,
        user: 'greenscore',
        password: 'hf&kdsp1',
        database: 'greenscore',
        insecureAuth: true
      });
      return this.conn.connect(function(err) {
        if (err) {
          return console.log(err);
        } else {
          return console.log("Connected to mySQL db");
        }
      });
    };

    HTTPRequestServer.prototype.mysql_query = function(query, onSuccess, onError) {
      /*
          @brief Allows client to make arbitrary sql queries.
      
          FIXME: THIS IS SO BAD OMG
      */
      if (this.conn === void 0) {
        return onError("No mySQL connection established");
      } else {
        return this.conn.query(query, (function(err, rows) {
          if (err === !null) {
            return onError(err);
          } else {
            return onSuccess(rows);
          }
        }));
      }
    };

    HTTPRequestServer.prototype.onUncaughtException = function(error) {
      /*
          @brief To handle uncaught exceptions (calling cmdHandler which doesn't
                 exist)
      
          @param error The error we're catching.
      */
      return console.log("uncaught exception: " + error);
    };

    return HTTPRequestServer;

  })();

  module.exports = HTTPRequestServer;

}).call(this);
